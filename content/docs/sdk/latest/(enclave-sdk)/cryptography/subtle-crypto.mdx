---
title: Subtle Crypto
---
import Image from 'next/image';

The Subtle Crypto Interface provides an advanced way to manage cryptographic operations such as encryption, decryption, signing, signature verifications, key wrapping/unwrapping, key import/export, etc.
The Key lifecycle management should be done by the developers. The Subtle Crypto interface offers more algoritm and cryptographic mode as well as configuration.

## Generating Keys
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `generateKey` | `algorithm: T, extractable: boolean, usages: string[]` | `Result<CryptoKey, Error>`  | Generate a `CryptoKey` based on the `algorithm` object and usages provided. Return a ResultSet `Result<CryptoKey, Error>` containing either the generated `CryptoKey` or an `Error`.|

        A `CryptoKey` contains the key type and usages and is an handle on the key.

        ```js copy
        class CryptoKey extends Key
        {
            algorithm!: string;
            extractable!: boolean;
            usages!: string[];
        }
        ```
    </Tab>
    <Tab value="Rust">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `generate_key` | `algorithm: GenAlgorithm, extractable: bool, usages: &[&str]` | `Result<CryptoKey, Error>`  | Generate a `CryptoKey` based on the `algorithm` object and usages provided. Return a ResultSet `Result<CryptoKey, Error>` containing either the generated `CryptoKey` or an `Error`.|

        A `CryptoKey` contains the key type, usages and is an handle on the key.

        ```rust
        pub struct CryptoKey {
            id: String,
            alias: Option<String>,
            key_type: String,
            extractable: bool,
            family: String,
            usages: Vec<String>,
            algorithm: String
        }
        ```
        Depending on the type of key that needs to be generated a `GenAlgorithm` `Enum variants` is passed as parameters.

        ```rust
        pub enum KeyGenAlgorithm {
            Rsa(RsaHashedKeyGenParams),
            Ecc(EcKeyGenParams),
            Aes(AesKeyGenParams),
            Hmac(HmacKeyGenParams),
        }
        ```
    </Tab>
</Tabs>

### RSA Key

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For generating RSA key, the algorithm object to use is `Crypto.RsaHashedKeyGenParams`.

        <Callout type="info">
            When generating an RSA Key, only the private key is generated and not a key pair.
            Usages needs to be align with that, for instance an RSA private key can only be used for signing, decrypting or unwraping.
        </Callout>

        ```js copy
        class RsaHashedKeyGenParams {
            modulusLength: u32 = 2048; // 2048, 3072, 4096
            publicExponent: u32 = 65537;
            hash: string = 'SHA2-256'; // "SHA2-256", "SHA2-384", "SHA2-512"
        }
        ```

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoRSA(): void
        {
            // Generate RSA key
            let rsaKey = Crypto.Subtle.generateKey({modulusLength: 2048, publicExponent: 65537, hash: "SHA2-256"} as Crypto.RsaHashedKeyGenParams, true, ["decrypt", "sign"]);
        }
        ```

        Public key derivation can be done directly from the private key and will automatically get the usages aligned with the private one.

        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `getPublicKey` | `key: CryptoKey` | `Result<CryptoKey, Error>`  | Derive the public `CryptoKey` corresponding to the private `key` provided. Return a ResultSet `Result<CryptoKey, Error>` containing either the generated `CryptoKey` or an `Error`.|

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoRSA(): void
        {
            // Generate RSA key
            let rsaKeyResult = Crypto.Subtle.generateKey({modulusLength: 2048, publicExponent: 65537, hash: "SHA2-256"} as Crypto.RsaHashedKeyGenParams, true, ["decrypt", "sign"]);
            let rsaKey = rsaKeyResult.data as Crypto.CryptoKey;
            // Derive RSA public key
            let publicRsaKeyResult = Crypto.Subtle.getPublicKey(rsaKey);
        }
        ```
    </Tab>
    <Tab value="Rust">
        For generating RSA key, the algorithm object to use is `RsaHashedKeyGenParams`.

        <Callout type="info">
            When generating an RSA Key, only the private key is generated and not a key pair.
            Usages needs to be align with that, for instance an RSA private key can only be used for signing, decrypting or unwraping.
        </Callout>

        ```rust
        pub struct RsaHashedKeyGenParams {
            pub modulus_length: u32, // 2048, 3072, 4096
            pub public_exponent: u32, // 65537
            pub hash: String // "SHA2-256", "SHA2-384", "SHA2-512"
        }
        ```

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_rsa(input: String) {
            let rsa_params = subtle::RsaHashedKeyGenParams {
                modulus_length: 2048,
                public_exponent: 65537,
                hash: "SHA2-256"
            };
            let key_usages_slice: Vec<&str> = vec!["decrypt", "sign"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Rsa(rsa_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
        Public key derivation can be done directly from the private key and will automatically get the usages aligned with the private one.

        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `get_public_key` | `key: CryptoKey` | `Result<CryptoKey, Error>`  | Derive the public `CryptoKey` corresponding to the private `key` provided. Return a ResultSet `Result<CryptoKey, Error>` containing either the generated `CryptoKey` or an `Error`.|

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_rsa(input: String) {
            let rsa_params = subtle::RsaHashedKeyGenParams {
                modulus_length: 2048,
                public_exponent: 65537,
                hash: "SHA2-256"
            };
            let key_usages_slice: Vec<&str> = vec!["decrypt", "sign"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Rsa(rsa_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            let public_crypto_key: CryptoKey = match subtle::get_public_key(&crypto_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

### EC Key

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For generating EC key, the algorithm object to use is `Crypto.EcKeyGenParams`.
        <Callout type="info">
            When generating an EC Key, only the private key is generated and not a key pair.
            Usages needs to be align with that, for instance an EC private key can only be used for signing or for derivation.
        </Callout>
        ```js copy
        export class EcKeyGenParams {
            namedCurve: string = 'P-256'; // "P-256", "P-384", "P-521"
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoEC(): void
        {
            // Generate EC key
            let eccKey = Crypto.Subtle.generateKey({namedCurve: "P-256"} as Crypto.EcKeyGenParams, true, ["sign"]);
        }
        ```
        Public key derivation can be done directly from the private key and will automatically get the usages aligned with the private one.

        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `getPublicKey` | `key: CryptoKey` | `Result<CryptoKey, Error>`  | Derive the public `CryptoKey` corresponding to the private `key` provided. Return a ResultSet `Result<CryptoKey, Error>` containing either the generated `CryptoKey` or an `Error`.|

        ```js copy
        /**
        * @query
        */
        export function subtleCryptoEC(): void
        {
            // Generate EC key
            let eccKey = Crypto.Subtle.generateKey({namedCurve: "P-256"} as Crypto.EcKeyGenParams, true, ["sign"]);
            // Derive Public key
            let public_eccKey = Crypto.Subtle.getPublicKey(eccKey);
        }
        ```
    </Tab>
    <Tab value="Rust">
        For generating EC key, the algorithm object to use is `EcKeyGenParams`.
        <Callout type="info">
            When generating an EC Key, only the private key is generated and not a key pair.
            Usages needs to be align with that, for instance an EC private key can only be used for signing or for derivation.
        </Callout>
        ```rust
        pub struct EcKeyGenParams {
            pub named_curve: String // "P-256", "P-384", "P-521"
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_ec(input: String) {
            let ec_params = subtle::EcKeyGenParams { named_curve: "P-256" };
            let key_usages_slice: Vec<&str> = vec!["sign"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Ecc(ec_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```

        Public key derivation can be done directly from the private key and will automatically get the usages aligned with the private one.

        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `get_public_key` | `key: CryptoKey` | `Result<CryptoKey, Error>`  | Derive the public `CryptoKey` corresponding to the private `key` provided. Return a ResultSet `Result<CryptoKey, Error>` containing either the generated `CryptoKey` or an `Error`.|

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_ec(input: String) {
            let ec_params = subtle::EcKeyGenParams { named_curve: "P-256" };
            let key_usages_slice: Vec<&str> = vec!["sign"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Ecc(ec_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            let public_key: CryptoKey = match subtle::get_public_key(&crypto_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```

    </Tab>
</Tabs>

### AES Key

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For generating AES key, the algorithm object to use is `Crypto.AesKeyGenParams`.

        ```js copy
        class AesKeyGenParams {
            length: u32 = 256; // 128, 192, 256
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoAES(): void
        {
            // Generate AES key
            let aesKey = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
        }
        ```
    </Tab>
    <Tab value="Rust">
        For generating AES key, the algorithm object to use is `AesKeyGenParams`.

        ```rust
        pub struct AesKeyGenParams {
            pub length: u32 // 128, 192, 256
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_aes(input: String) {
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let key_usages_slice: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Aes(aes_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

### HMAC Key

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For generating HMAC key, the algorithm object to use is `Crypto.HmacKeyGenParams`.

        ```js copy
        export class HmacKeyGenParams {
            hash: string = 'SHA2-256'; //SHA2-384, SHA2-512
            length: u16 = 0; // Optional - if not set, keys are automatically sized to the block size of the sha algorithm.
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoHMAC(): void
        {
            // Generate HMAC key
            let hmacKey = Crypto.Subtle.generateKey({hash: 'SHA2-256'} as Crypto.HmacKeyGenParams, true, ["sign", "verify"]);
        }
        ```
    </Tab>
    <Tab value="Rust">
        For generating HMAC key, the algorithm object to use is `HmacKeyGenParams`.

        ```rust
        pub struct HmacKeyGenParams {
            pub hash: String, // "SHA2-256", "SHA2-384", "SHA2-512"
            pub length: u16, // Optional - if not set, keys are automatically sized to the block size of the sha algorithm.
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_hmac(input: String) {
            let hmac_params = subtle::HmacKeyGenParams { hash: "SHA2-256".to_string() };
            let key_usages_slice: Vec<&str> = vec!["sign", "verify"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Hmac(hmac_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

## Data encryption and decryption

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">

    | Class  | Operation  | Parameters: type | Returns | Behavior |
    |--------|------------|------------------|---------|----------|
    |`Crypto.Subtle`| `encrypt` | `algorithm: T, key: CryptoKey, clearText: ArrayBuffer` | `Result<ArrayBuffer, Error>`  | Encrypt the `clearText` with the `algorithm` object and `key`provided. Return an `ArrayBuffer` containing the cipherText or an `Error`.|
    |`Crypto.Subtle`| `decrypt` | `algorithm: T, key: CryptoKey, cipherText: ArrayBuffer`| `Result<ArrayBuffer, Error>` | Decrypt the `cipherText` with the `algorithm` object and `key`provided. Return an `ArrayBuffer` containing the clearText or an `Error`.|

    </Tab>
    <Tab value="Rust">

    | Class  | Operation  | Parameters: type | Returns | Behavior |
    |--------|------------|------------------|---------|----------|
    |`crypto::subtle`| `encrypt` | `algorithm: EncryptAlgorithm, key: CryptoKey, clearText: [u8]` | `Result<Vec<u8>, Error>`  | Encrypt the `clearText` with the `algorithm` object and `key`provided. Return an `ArrayBuffer` containing the cipherText or an `Error`.|
    |`crypto::subtle`| `decrypt` | `algorithm: EncryptAlgorithm, key: CryptoKey, cipherText: [u8]`| `Result<Vec<u8>, Error>` | Decrypt the `cipherText` with the `algorithm` object and `key`provided. Return an `ArrayBuffer` containing the clearText or an `Error`.|

    Depending on the type of encryption that needs to be done an `EncryptAlgorithm` `Enum variants` is passed as parameters.

    ```rust
    pub enum EncryptAlgorithm {
        RsaOaep(RsaOaepParams),
        AesGcm(AesGcmParams),
    }
    ```
    </Tab>
</Tabs>

### AES-GCM

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For encrypting with AES-GCM you need an AES key and to use the `Crypto.AesGcmParams` algorithm object.

        ```js copy
        class AesGcmParams {
            iv!: ArrayBuffer; // iv cannot be empty
            additionalData: ArrayBuffer = new ArrayBuffer(0);
            tagLength: u32 = 128;
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoAESGCM(): void
        {
            // Generate AES key
            let aesKeyResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
            let aesKey = aesKeyResult.data as Crypto.CryptoKey;
            // Generate iv
            let iv = Crypto.getRandomValues(12);
            let aesGcmParams = {iv : iv.buffer, additionalData : new ArrayBuffer(0),  tagLength : 128} as Crypto.AesGcmParams;
            let cipher = Crypto.Subtle.encrypt(aesGcmParams, aesKey, String.UTF8.encode("Hello World"));
            let clearText = Crypto.Subtle.decrypt(aesGcmParams, aesKey, cipher.data as ArrayBuffer);
        }
        ```
    </Tab>
    <Tab value="Rust">
        For encrypting with AES-GCM you need an AES key and to use the `Crypto.AesGcmParams` algorithm object.

        ```rust
        pub struct AesGcmParams {
            pub iv: Vec<u8>, // iv cannot be empty
            pub additional_data: Vec<u8>,
            pub tag_length: u32
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_aes_gcm(input: String) {
            // Generate AES key
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let key_usages_slice: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Aes(aes_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate IV
            let random_bytes = match klave::crypto::random::get_random_bytes(12) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            //Generate GCM parameters
            let aes_params = subtle::AesGcmParams {
                iv: &random_bytes,
                additionalData: vec![],
                tagLength: 128
            };
            let crypt_algorithm = subtle::EncryptAlgorithm::AesGcm(aes_params);

            // Encrypt
            let encrypted_text = match subtle::encrypt(&crypt_algorithm, &crypto_key, &String::from("Hello World").into_bytes()) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Decrypt
            let decrypted_text = match subtle::decrypt(&crypt_algorithm, &crypto_key, &encrypted_text) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

### RSA-OAEP

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For encrypting with RSA-OAEP you need an RSA key and to use the `Crypto.RsaOaepParams` algorithm object.

        ```js copy
        export class RsaOaepParams {
            label: ArrayBuffer = new ArrayBuffer(0);
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoRSAOAEP(): void
        {
            // Generate RSA key
            let rsakeyResult = Crypto.Subtle.generateKey({modulusLength: 2048, publicExponent: 65537, hash: "SHA2-256"} as Crypto.RsaHashedKeyGenParams, true, ["encrypt", "decrypt"]);
            let rsaKey = rsakeyResult.data as Crypto.CryptoKey;
            // Encrypt and Decrypt
            let rsaOaepParams = {label : new ArrayBuffer(0)} as Crypto.RsaOaepParams;
            let cipher = Crypto.Subtle.encrypt(rsaOaepParams, rsaKey, String.UTF8.encode("Hello World"));
            let clearText = Crypto.Subtle.decrypt(rsaOaepParams, rsaKey, cipher.data as ArrayBuffer);
        }
        ```
    </Tab>
    <Tab value="Rust">
        For encrypting with RSA-OAEP you need an RSA key and to use the `RsaOaepParams` algorithm object.

        ```rust
        pub struct RsaOaepParams {
            pub label: Vec<u8>
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_rsa_oaep(input: String) {
            // Generate RSA key
            let rsa_params = subtle::RsaHashedKeyGenParams {
                modulus_length: 2048,
                public_exponent: 65537,
                hash: "SHA2-256"
            };
            let key_usages_slice: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Rsa(rsa_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Encrypt
            let rsa_oaep_params = subtle::RsaOaepParams { label: vec![] };
            let crypt_algorithm = subtle::EncryptAlgorithm::RsaOaep(rsa_oaep_params);
            let encrypted_text = match subtle::encrypt(&crypt_algorithm, &crypto_key, &String::from("Hello World").into_bytes()) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Decrypt
            let decrypted_text = match subtle::decrypt(&crypt_algorithm, &crypto_key, &encrypted_text) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

## Signing and Verifying
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">

    | Class  | Operation  | Parameters: type | Returns | Behavior |
    |--------|------------|------------------|---------|----------|
    |`Crypto.Subtle`| `sign` | `algorithm: T, key: CryptoKey, data: ArrayBuffer` | `Result<ArrayBuffer, Error>`  | Sign the `data` with the `algorithm` object and `key` provided. Return an `ArrayBuffer` containing the signature or an `Error`.|
    |`Crypto.Subtle`| `verify` | `algorithm: T, key: CryptoKey, data: ArrayBuffer, signature: ArrayBuffer`| `Result<Crypto.SignatureVerification, Error>` | Verify the `signature` against the `data` with the `algorithm` object and `key` provided. Return an `Crypto.SignatureVerification` containing a boolean or an `Error`.|

    </Tab>
    <Tab value="Rust">

    | Class  | Operation  | Parameters: type | Returns | Behavior |
    |--------|------------|------------------|---------|----------|
    |`crypto::subtle`| `sign` | `algorithm: SignAlgorithm, key: CryptoKey, data: [u8]` | `Result<Vec<u8>, Error>`  | Sign the `data` with the `algorithm` object and `key` provided. Return an `Vec<u8>` containing the signature or an `Error`.|
    |`crypto::subtle`| `verify` | `algorithm: SignAlgorithm, key: CryptoKey, data: [u8], signature: [u8]`| `Result<VerifySignResult, Error>` | Verify the `signature` against the `data` with the `algorithm` object and `key` provided. Return an `VerifySignResult` containing a bool or an `Error`.|

    Depending on the type of signature that needs to be done a `SignAlgorithm` `Enum variants` is passed as parameters.

    ```rust
    pub enum SignAlgorithm {
        Ecdsa(EcdsaParams),
        RsaPss(RsaPssParams),
        Hmac(HmacParams),
    }
    ```
    </Tab>
</Tabs>

### ECDSA
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For ECDSA signature you need an EC key pair and to use the `Crypto.EcdsaParams` algorithm object.

        ```js copy
        export class EcdsaParams {
            hash: string = 'SHA2-256'; // "SHA2-256", "SHA2-384", "SHA2-512"
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoECDSA(): void
        {
            // Generate EC key
            let eccKeyResult = Crypto.Subtle.generateKey({namedCurve: "P-256"} as Crypto.EcKeyGenParams, true, ["sign", "verify"]);
            let eccKey = eccKeyResult.data as Crypto.CryptoKey;
            // Sign and Verify
            let ecdsaParams = {hash: "SHA2-256"} as Crypto.EcdsaParams;
            let signEcc = Crypto.Subtle.sign(ecdsaParams, eccKey, String.UTF8.encode("Hello World"));
            let verifyEcc = Crypto.Subtle.verify(ecdsaParams, eccKey, String.UTF8.encode("Hello World"), signEcc.data as ArrayBuffer);
            let verification = verifyEcc.data as SignatureVerification;
            // Validate signature : if(verification.isValid) ...
        }
        ```
    </Tab>
    <Tab value="Rust">
        For ECDSA signature you need an EC key pair and to use the `EcdsaParams` algorithm object.

        ```rust
        pub struct EcdsaParams {
            pub hash: String // "SHA2-256", "SHA2-384", "SHA2-512"
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_ecdsa(input: String) {
            // Generate Key
            let ec_params = subtle::EcKeyGenParams { named_curve: "P-256" };
            let key_usages_slice: Vec<&str> = vec!["sign", "verify"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Ecc(ec_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            // Sign
            let sign_ec_params = subtle::EcdsaParams { hash: "SHA2-256" };
            let sign_algorithm = subtle::SignAlgorithm::Ecdsa(sign_ec_params);
            let signature = match subtle::sign(&sign_algorithm, &crypto_key, &String::from("Hello World").into_bytes()) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            // Verify
            let verify_result = match subtle::verify(&sign_algorithm, &crypto_key, &String::from("Hello World").into_bytes(), &signature) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            if verify_result.is_valid() {
                klave::notifier::send_string("Verified");
            }
            else {
                klave::notifier::send_string("Not Verified");
            }
        }
        ```
    </Tab>
</Tabs>

### RSA-PSS
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For RSA-PSS signature you need an RSA key pair and to use the `Crypto.RsaPssParams` algorithm object.

        ```js copy
        export class RsaPssParams {
            saltLength: u32 = 0;
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoRSAPSS(): void
        {
            // Generate RSA key
            let rsaKeyResult = Crypto.Subtle.generateKey({modulusLength: 2048, publicExponent: 65537, hash: "SHA2-256"} as Crypto.RsaHashedKeyGenParams, true, ["sign", "verify"]);
            let rsaKey = rsaKeyResult.data as Crypto.CryptoKey;
            // Sign and Verify
            let rsaPssParams = {saltLength: 32} as Crypto.RsaPssParams;
            let signRsa = Crypto.Subtle.sign(rsaPssParams, rsaKey, String.UTF8.encode("Hello World"));
            let verifyRsa = Crypto.Subtle.verify(rsaPssParams, rsaKey, String.UTF8.encode("Hello World"), signRsa.data as ArrayBuffer);
            let verification = verifyRsa.data as SignatureVerification;
            // Validate signature : if(verification.isValid) ...
        }
        ```
    </Tab>
    <Tab value="Rust">
        For RSA-PSS signature you need an RSA key pair and to use the `RsaPssParams` algorithm object.

        ```rust
        pub struct RsaPssParams {
            pub salt_length: u32
        }
        ```
        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_rsa_pss(input: String) {
            // Generate RSA key
            let rsa_params = subtle::RsaHashedKeyGenParams {
                modulus_length: 2048,
                public_exponent: 65537,
                hash: "SHA2-256"
            };
            let key_usages_slice: Vec<&str> = vec!["sign", "verify"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Rsa(rsa_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            // Sign
            let sign_rsa_params = subtle::RsaPssParams { salt_length: 0 };
            let sign_algorithm = subtle::SignAlgorithm::RsaPss(sign_rsa_params);
            let signature = match subtle::sign(&sign_algorithm, &crypto_key, &String::from("Hello World").into_bytes()) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            // Verify
            let verify_result = match subtle::verify(&sign_algorithm, &crypto_key, &String::from("Hello World").into_bytes(), &signature) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            if verify_result.is_valid() {
                klave::notifier::send_string("Verified");
            }
            else {
                klave::notifier::send_string("Not Verified");
            }
        }
        ```
    </Tab>
</Tabs>

### HMAC
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For HMAC signature you need an HMAC key and to use the `Crypto.HmacKeyGenParams` algorithm object.

        ```js copy
        export class NamedAlgorithm {
            name!: string; // HMAC
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoHMAC(): void
        {
            // Generate HMAC key
            let hmacKeyResult = Crypto.Subtle.generateKey({hash: 'SHA2-256'} as Crypto.HmacKeyGenParams, true, ["sign", "verify"]);
            let hmacKey = hmacKeyResult.data as Crypto.CryptoKey;
            // Sign and Verify
            let hmacParams = {name: 'HMAC'} as Crypto.NamedAlgorithm;
            let signHmac = Crypto.Subtle.sign(hmacParams, hmacKey, String.UTF8.encode("Hello World"));
            let verifyHmac = Crypto.Subtle.verify(hmacParams, hmacKey, String.UTF8.encode("Hello World"), signHmac.data as ArrayBuffer);
            let verification = verifyHmac.data as SignatureVerification;
            // Validate signature : if(verification.isValid) ...
        }
        ```
    </Tab>
    <Tab value="Rust">
        For HMAC signature you need an HMAC key and to use the `HmacParams` algorithm object.

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_hmac(input: String) {
            // Generate HMAC key
            let hmac_params = subtle::HmacKeyGenParams { hash: "SHA2-256".to_string() };
            let key_usages_slice: Vec<&str> = vec!["sign", "verify"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Hmac(hmac_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            // Sign
            let sign_algorithm = subtle::SignAlgorithm::Hmac();
            let signature = match subtle::sign(&sign_algorithm, &crypto_key, &String::from("Hello World").into_bytes()) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            // Verify
            let verify_result = match subtle::verify(&sign_algorithm, &crypto_key, &String::from("Hello World").into_bytes(), &signature) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            if verify_result.is_valid() {
                klave::notifier::send_string("Verified");
            }
            else {
                klave::notifier::send_string("Not Verified");
            }
        }
        ```
    </Tab>
</Tabs>

## Key derivation
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `deriveKey` | `algorithm: T, baseKeyName: CryptoKey, derivedKeyAlgorithm: E, extractable: boolean, usages: string[]`| `Result<CryptoKey, Error>` | Wrap the `key`in the `format` specified with the `wrappingKey` using the wrapping `algorithm`. Return an `ArrayBuffer` containing the wrapped key or an `Error`.|
        
        There are multiple types of key derivation algorithm available for `algorithm`: `EcdhKeyDeriveParams` and `HmacKeyGenParams`.

        ```js
        class EcdhKeyDeriveParams {
            name: string = 'ECDH';
            publicKey!: CryptoKey; // The public key to derive the shared secret from
        }

        class HkdfParams {
            hash: string = 'SHA2-256'; //SHA2-384, SHA2-512
            salt: ArrayBuffer;
            info: ArrayBuffer;
        }
        ```

        There are multiple types of derived key that can be built, represented by `derivedKeyAlgorithm` : `AesKeyGenParams` and `HmacKeyGenParams`.

        ```js
        class AesKeyGenParams {
            length: u32 = 256;
        }

        class HmacKeyGenParams {
            hash: string = 'SHA2-256'; //SHA2-384, SHA2-512
        }
        ```
    </Tab>
    <Tab value="Rust">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `derive_key` | `derivation_algorithm: KeyDerivationAlgorithm, base_key: CryptoKey, derived_key_algorithm: DerivedKeyAlgorithm, extractable: bool, usages: [&str]` | `Result<CryptoKey, Error>`  | Use the `derivation_algorithm` to derive the `base_key` key into a new `CryptoKey` built from the `derived_key_algorithm` algoritm. Return the derived key as a `CryptoKey` or an `Error`.|

        There are multiple types of key derivation algorithm available and represented by `KeyDerivationAlgorithm` as well as different derived key that can be built, represented by `DerivedKeyAlgorithm`.

        ```rust
        pub enum KeyDerivationAlgorithm {
            Ecdh(EcdhDerivParams),
            Hkdf(HkdfDerivParams),
        }

        pub enum DerivedKeyAlgorithm {
            Aes(AesKeyGenParams),
            Hmac(HmacKeyGenParams),
        }
        ```
    </Tab>
</Tabs>

### ECDH 
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For ECDH key derivation you need an EC private key and a public key to derive the shared secret from. Use `Crypto.EcdhKeyDeriveParams` for the derivation algorithm.

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoECDH_AES(): void
        {
            // Generate EC key pair
            let eccPrivateKeyResult = Crypto.Subtle.generateKey({namedCurve: "P-256"} as Crypto.EcKeyGenParams, true, ["deriveBits", "deriveKey"]);
            let eccPrivateKey = eccPrivateKeyResult.data as Crypto.CryptoKey;
            
            // Get the corresponding public key
            let eccPublicKeyResult = Crypto.Subtle.getPublicKey(eccPrivateKey);
            let eccPublicKey = eccPublicKeyResult.data as Crypto.CryptoKey;

            // Derive AES key using ECDH
            let ecdhParams = {publicKey: eccPublicKey} as Crypto.EcdhKeyDeriveParams;
            let derivedAesKeyResult = Crypto.Subtle.deriveKey(
                ecdhParams, 
                eccPrivateKey, 
                {length: 256} as Crypto.AesKeyGenParams, 
                true, 
                ["encrypt", "decrypt"]
            );
            let derivedAesKey = derivedAesKeyResult.data as Crypto.CryptoKey;
        }
        ```

        You can also derive an HMAC key from the same ECDH shared secret:

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoECDH_HMAC(): void
        {
            // Generate EC key pair
            let eccPrivateKeyResult = Crypto.Subtle.generateKey({namedCurve: "P-256"} as Crypto.EcKeyGenParams, true, ["deriveBits", "deriveKey"]);
            let eccPrivateKey = eccPrivateKeyResult.data as Crypto.CryptoKey;
            
            // Get the corresponding public key
            let eccPublicKeyResult = Crypto.Subtle.getPublicKey(eccPrivateKey);
            let eccPublicKey = eccPublicKeyResult.data as Crypto.CryptoKey;

            // Derive HMAC key using ECDH
            let ecdhParams = {publicKey: eccPublicKey} as Crypto.EcdhKeyDeriveParams;
            let derivedHmacKeyResult = Crypto.Subtle.deriveKey(
                ecdhParams, 
                eccPrivateKey, 
                {hash: "SHA2-256"} as Crypto.HmacKeyGenParams, 
                true, 
                ["sign", "verify"]
            );
            let derivedHmacKey = derivedHmacKeyResult.data as Crypto.CryptoKey;
        }
        ```
    </Tab>
    <Tab value="Rust">
        For ECDH key derivation you need an EC private key and a public key to derive the shared secret from. Use `EcdhDerivParams` for the derivation algorithm.

        ```rust
        pub struct EcdhDerivParams {
            pub public_key: CryptoKey // The public key to derive the shared secret from
        }
        ```

        Example deriving an AES key using ECDH:

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_ecdh_aes(input: String) {
            // Generate EC private key
            let ec_params = subtle::EcKeyGenParams { named_curve: "P-256".to_string() };
            let key_usages_slice: Vec<&str> = vec!["deriveBits", "deriveKey"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Ecc(ec_params);
            let private_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Get the corresponding public key
            let public_key: CryptoKey = match subtle::get_public_key(&private_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Derive AES key using ECDH
            let ecdh_params = subtle::EcdhDerivParams { public_key };
            let derivation_algorithm = subtle::KeyDerivationAlgorithm::Ecdh(ecdh_params);
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let derived_key_algorithm = subtle::DerivedKeyAlgorithm::Aes(aes_params);
            let key_usages_derived: Vec<&str> = vec!["encrypt", "decrypt"];
            
            let derived_aes_key: CryptoKey = match subtle::derive_key(
                &derivation_algorithm,
                &private_key,
                &derived_key_algorithm,
                true,
                &key_usages_derived
            ) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```

        Example deriving an HMAC key using ECDH:

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_ecdh_hmac(input: String) {
            // Generate EC private key
            let ec_params = subtle::EcKeyGenParams { named_curve: "P-256".to_string() };
            let key_usages_slice: Vec<&str> = vec!["deriveBits", "deriveKey"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Ecc(ec_params);
            let private_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Get the corresponding public key
            let public_key: CryptoKey = match subtle::get_public_key(&private_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Derive HMAC key using ECDH
            let ecdh_params = subtle::EcdhDerivParams { public_key };
            let derivation_algorithm = subtle::KeyDerivationAlgorithm::Ecdh(ecdh_params);
            let hmac_params = subtle::HmacKeyGenParams { hash: "SHA2-256".to_string() };
            let derived_key_algorithm = subtle::DerivedKeyAlgorithm::Hmac(hmac_params);
            let key_usages_derived: Vec<&str> = vec!["sign", "verify"];
            
            let derived_hmac_key: CryptoKey = match subtle::derive_key(
                &derivation_algorithm,
                &private_key,
                &derived_key_algorithm,
                true,
                &key_usages_derived
            ) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

### HKDF
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        For HKDF key derivation you need a base key material and use `Crypto.HkdfParams` for the derivation algorithm. HKDF (HMAC-based Key Derivation Function) is useful for deriving keys from shared secrets or other key material.

        ```js copy
        export class HkdfParams {
            hash: string = 'SHA2-256'; // "SHA2-256", "SHA2-384", "SHA2-512"
            salt: ArrayBuffer;
            info: ArrayBuffer;
        }
        ```

        Example deriving an AES key using HKDF:

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoHKDF_AES(): void
        {
            // Generate base key material (could be from ECDH or any other source)
            let baseKeyResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["deriveKey"]);
            let baseKey = baseKeyResult.data as Crypto.CryptoKey;

            // Prepare HKDF parameters
            let salt = Crypto.getRandomValues(16); // 16 bytes salt
            let info = String.UTF8.encode("AES-key-derivation"); // Context info
            let hkdfParams = {
                hash: "SHA2-256",
                salt: salt.buffer,
                info: info
            } as Crypto.HkdfParams;

            // Derive AES key using HKDF
            let derivedAesKeyResult = Crypto.Subtle.deriveKey(
                hkdfParams,
                baseKey,
                {length: 256} as Crypto.AesKeyGenParams,
                true,
                ["encrypt", "decrypt"]
            );
            let derivedAesKey = derivedAesKeyResult.data as Crypto.CryptoKey;
        }
        ```

        Example deriving an HMAC key using HKDF:

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoHKDF_HMAC(): void
        {
            // Generate base key material
            let baseKeyResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["deriveKey"]);
            let baseKey = baseKeyResult.data as Crypto.CryptoKey;

            // Prepare HKDF parameters
            let salt = Crypto.getRandomValues(32); // 32 bytes salt
            let info = String.UTF8.encode("HMAC-key-derivation"); // Context info
            let hkdfParams = {
                hash: "SHA2-256",
                salt: salt.buffer,
                info: info
            } as Crypto.HkdfParams;

            // Derive HMAC key using HKDF
            let derivedHmacKeyResult = Crypto.Subtle.deriveKey(
                hkdfParams,
                baseKey,
                {hash: "SHA2-256"} as Crypto.HmacKeyGenParams,
                true,
                ["sign", "verify"]
            );
            let derivedHmacKey = derivedHmacKeyResult.data as Crypto.CryptoKey;
        }
        ```
    </Tab>
    <Tab value="Rust">
        For HKDF key derivation you need a base key material and use `HkdfDerivParams` for the derivation algorithm. HKDF (HMAC-based Key Derivation Function) is useful for deriving keys from shared secrets or other key material.

        ```rust
        pub struct HkdfDerivParams {
            pub hash: String, // "SHA2-256", "SHA2-384", "SHA2-512"
            pub salt: Vec<u8>,
            pub info: Vec<u8>
        }
        ```

        Example deriving an AES key using HKDF:

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_hkdf_aes(input: String) {
            // Generate base key material (could be from ECDH or any other source)
            let aes_params_base = subtle::AesKeyGenParams { length: 256 };
            let key_usages_base: Vec<&str> = vec!["deriveKey"];
            let gen_algorithm_base = subtle::KeyGenAlgorithm::Aes(aes_params_base);
            let base_key: CryptoKey = match subtle::generate_key(&gen_algorithm_base, true, &key_usages_base) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate salt and info
            let salt = match klave::crypto::random::get_random_bytes(16) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            let info = "AES-key-derivation".as_bytes().to_vec();

            // Prepare HKDF parameters
            let hkdf_params = subtle::HkdfDerivParams {
                hash: "SHA2-256".to_string(),
                salt,
                info
            };
            let derivation_algorithm = subtle::KeyDerivationAlgorithm::Hkdf(hkdf_params);
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let derived_key_algorithm = subtle::DerivedKeyAlgorithm::Aes(aes_params);
            let key_usages_derived: Vec<&str> = vec!["encrypt", "decrypt"];

            // Derive AES key using HKDF
            let derived_aes_key: CryptoKey = match subtle::derive_key(
                &derivation_algorithm,
                &base_key,
                &derived_key_algorithm,
                true,
                &key_usages_derived
            ) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```

        Example deriving an HMAC key using HKDF:

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_hkdf_hmac(input: String) {
            // Generate base key material
            let aes_params_base = subtle::AesKeyGenParams { length: 256 };
            let key_usages_base: Vec<&str> = vec!["deriveKey"];
            let gen_algorithm_base = subtle::KeyGenAlgorithm::Aes(aes_params_base);
            let base_key: CryptoKey = match subtle::generate_key(&gen_algorithm_base, true, &key_usages_base) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate salt and info
            let salt = match klave::crypto::random::get_random_bytes(32) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
            let info = "HMAC-key-derivation".as_bytes().to_vec();

            // Prepare HKDF parameters
            let hkdf_params = subtle::HkdfDerivParams {
                hash: "SHA2-256".to_string(),
                salt,
                info
            };
            let derivation_algorithm = subtle::KeyDerivationAlgorithm::Hkdf(hkdf_params);
            let hmac_params = subtle::HmacKeyGenParams { hash: "SHA2-256".to_string() };
            let derived_key_algorithm = subtle::DerivedKeyAlgorithm::Hmac(hmac_params);
            let key_usages_derived: Vec<&str> = vec!["sign", "verify"];

            // Derive HMAC key using HKDF
            let derived_hmac_key: CryptoKey = match subtle::derive_key(
                &derivation_algorithm,
                &base_key,
                &derived_key_algorithm,
                true,
                &key_usages_derived
            ) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

## Key wrapping
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `wrapKey` | `format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgo: T` | `Result<ArrayBuffer, Error>`  | Wrap the `key`in the `format` specified with the `wrappingKey` using the wrapping `algorithm`. Return an `ArrayBuffer` containing the wrapped key or an `Error`.|
        |`Crypto.Subtle`| `unwrapKey` | `format: string, wrappedKey: ArrayBuffer, unwrappingKey: CryptoKey, unwrapAlgo: T, unwrappedKeyAlgo: E, extractable: boolean, usages: string[]`| `Result<CryptoKey, Error>` | Unwrap the `wrappedKey` wrapped in the `format` with the `unwrappingKey` and `unwrapAlgo` and create a `Cryptokey` with the specified `unwrappedKeyAlgo` and parameters. Return a result set containing a `Crypto.CryptoKey` or an `Error`.|

        Format that can be used depending on the key you want to wrap/unwrap are the following: `raw`, `spki`, `pkcs8`, `pkcs1`, `sec1`.
    </Tab>
    <Tab value="Rust">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `wrap_key` | `format: string, key: CryptoKey, wrapping_key: CryptoKey, algorithm: WrapAlgorithm` | `Result<Vec<u8>, Error>`  | Wrap the `key`in the `format` specified with the `wrapping_key` using the wrapping `algorithm`. Return an `Vec<u8>` containing the wrapped key or an `Error`.|
        |`crypto::subtle`| `unwrap_key` | `format: string, wrappedKey: [u8], unwrapping_key: CryptoKey, unwrap_algorithm: WrapAlgorithm, unwrapped_key_algorithm: GenAlgorithm, extractable: bool, usages: [&str]`| `Result<CryptoKey, Error>` | Unwrap the `wrapped_key` wrapped in the `format` with the `unwrapping_key` and `unwrap_algorithm` and create a `Cryptokey` with the specified `unwrapped_key_algorithm` and parameters. Return a result set containing a `CryptoKey` or an `Error`.|

        Depending on the type of wrapping that needs to be done a `WrapAlgorithm` `Enum variants` is passed as parameters.

        ```rust
        pub enum KeyWrapAlgorithm {
            RsaOaep(RsaOaepParams),
            AesGcm(AesGcmParams),
            AesKw,
        }
        ```
        Format that can be used depending on the key you want to wrap/unwrap are the following: `raw`, `spki`, `pkcs8`, `pkcs1`, `sec1`.
    </Tab>
</Tabs>

### AES-KW
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        To wrap and unwrap key with AES-KW you will need an AES key, a key to wrap and to use `NamedAlgorithm`.

        ```js copy
        export class NamedAlgorithm {
            name!: string;
        }
        ```
        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoAESKW(): void
        {
            // Generate wrapping AES key
            let aesKeyResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["wrap_key", "unwrap_key"]);
            let aesKey = aesKeyResult.data as Crypto.CryptoKey;

            // Generate AES key to wrap
            let aesKeyToWrapResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
            let aesKeyToWrap = aesKeyToWrapResult.data as Crypto.CryptoKey;

            // Wrap and Unwrap
            let aesKwParams = {name: "AES-KW"} as Crypto.NamedAlgorithm;
            let wrappedKeyResult = Crypto.Subtle.wrapKey("raw", aesKeyToWrap, aesKey, aesKwParams);
            let unwrappedKeyResult = Crypto.Subtle.unwrapKey("raw", wrappedKeyResult.data, aesKey, aesKwParams, {length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
        }
        ```
    </Tab>
    <Tab value="Rust">
        To wrap and unwrap key with AES-KW you will need an AES key and a key to wrap .

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_aes_kw(input: String) {
            // Generate wrapping AES key
            let aes_params_wrap_key = subtle::AesKeyGenParams { length: 256 };
            let key_usages_wrap_key: Vec<&str> = vec!["wrap_key", "unwrap_key"];
            let gen_algorithm_wrap_key = subtle::KeyGenAlgorithm::Aes(aes_params_wrap_key);
            let wrapping_key: CryptoKey = match subtle::generate_key(&gen_algorithm_wrap_key, true, &key_usages_wrap_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate AES key to wrap
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let key_usages_slice: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Aes(aes_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Wrap
            let kw_wrap_algo = subtle::KeyWrapAlgorithm::AesKw;
            let wrapped_key = match subtle::wrap_key(&"raw", &crypto_key, &wrapping_key, &kw_wrap_algo) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Unwrap
            let unwrapped_key = match subtle::unwrap_key(&"raw", &wrapped_key, &wrapping_key,
                &kw_wrap_algo,
                &gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

### AES-GCM
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        To wrap and unwrap key with AES-GCM you will need an AES key, a key to wrap and to use `Crypto.AesGcmParams` algorithm object.

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoAESGCM(): void
        {
            // Generate wrapping AES key
            let aesKeyResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["wrap_key", "unwrap_key"]);
            let aesKey = aesKeyResult.data as Crypto.CryptoKey;

            // Generate AES key to wrap
            let aesKeyToWrapResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
            let aesKeyToWrap = aesKeyToWrapResult.data as Crypto.CryptoKey;

            // Wrap and Unwrap
            let iv = Crypto.getRandomValues(12);
            let aesGcmParams = {iv : iv.buffer, additionalData : new ArrayBuffer(0),  tagLength : 128} as Crypto.AesGcmParams;
            let wrappedKeyResult = Crypto.Subtle.wrapKey("raw", aesKeyToWrap, aesKey, aesGcmParams);
            let unwrappedKeyResult = Crypto.Subtle.unwrapKey("raw", wrappedKeyResult.data, aesKey, aesGcmParams, {length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
        }
        ```
    </Tab>
    <Tab value="Rust">
        To wrap and unwrap key with AES-GCM you will need an AES key, a key to wrap and to use `AesGcmParams` algorithm object.

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_aes_gcm_wrap(input: String) {
            // Generate wrapping AES key
            let aes_params_wrap_key = subtle::AesKeyGenParams { length: 256 };
            let key_usages_wrap_key: Vec<&str> = vec!["wrap_key", "unwrap_key"];
            let gen_algorithm_wrap_key = subtle::KeyGenAlgorithm::Aes(aes_params_wrap_key);
            let wrapping_key: CryptoKey = match subtle::generate_key(&gen_algorithm_wrap_key, true, &key_usages_wrap_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate AES key to wrap
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let key_usages_slice: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Aes(aes_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate IV
            let random_bytes = match klave::crypto::random::get_random_bytes(12) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            //Generate GCM parameters
            let aes_gcm_params = subtle::AesGcmParams {
                iv: &random_bytes,
                additionalData: vec![],
                tagLength: 128
            };
            let wrapping_algorithm = subtle::KeyWrapAlgorithm::AesGcm(aes_params);

            // Wrap
            let wrapped_key = match subtle::wrap_key(&"raw", &crypto_key, &wrapping_key, &wrapping_algorithm) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Unwrap
            let unwrapped_key = match subtle::unwrap_key(&"raw", &wrapped_key, &wrapping_key,
                &wrapping_algorithm,
                &gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

### RSA-OAEP
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        To wrap and unwrap key with RSA-OAEP you will need an RSA key, a key to wrap and to use `Crypto.RsaOaepParams` algorithm object.

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoRSAOAEP(): void
        {
            // Generate wrapping RSA key
            let rsakeyResult = Crypto.Subtle.generateKey({modulusLength: 2048, publicExponent: 65537, hash: "SHA2-256"} as Crypto.RsaHashedKeyGenParams, true, ["wrap_key", "unwrap_key"]);
            let rsaKey = rsakeyResult.data as Crypto.CryptoKey;

            // Generate AES key to wrap
            let aesKeyToWrapResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
            let aesKeyToWrap = aesKeyToWrapResult.data as Crypto.CryptoKey;

            // Wrap and Unwrap
            let rsaOaepParams = {label : new ArrayBuffer(0)} as Crypto.RsaOaepParams;
            let wrappedKeyResult = Crypto.Subtle.wrapKey("raw", aesKeyToWrap, rsaKey, rsaOaepParams);
            let unwrappedKeyResult = Crypto.Subtle.unwrapKey("raw", wrappedKeyResult.data, rsaKey, rsaOaepParams, {length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
        }
        ```
    </Tab>
    <Tab value="Rust">
        To wrap and unwrap key with RSA-OAEP you will need an RSA key, a key to wrap and to use `RsaOaepParams` algorithm object.

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_rsa_oaep_wrap(input: String) {
            // Generate wrapping RSA key
            let rsa_params_wrap_key = subtle::RsaHashedKeyGenParams {
                modulus_length: 2048,
                public_exponent: 65537,
                hash: "SHA2-256"
            };
            let key_usages_wrap_key: Vec<&str> = vec!["wrap_key", "unwrap_key"];
            let gen_algorithm_wrap_key = subtle::KeyGenAlgorithm::Rsa(rsa_params_wrap_key);
            let wrapping_key: CryptoKey = match subtle::generate_key(&gen_algorithm_wrap_key, true, &key_usages_wrap_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Generate AES key to wrap
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let key_usages_slice: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Aes(aes_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            //Generate RSA-OAEP parameters
            let rsa_oaep_params = subtle::RsaOaepParams { label: vec![] };
            let wrapping_algorithm = subtle::KeyWrapAlgorithm::RsaOaep(rsa_oaep_params);

            // Wrap
            let wrapped_key = match subtle::wrap_key(&"raw", &crypto_key, &wrapping_key, &wrapping_algorithm) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Unwrap
            let unwrapped_key = match subtle::unwrap_key(&"raw", &wrapped_key, &wrapping_key,
                &wrapping_algorithm,
                &gen_algorithm, true, &key_usages_slice) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>

## Importing and Exporting key

<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `importKey` | `format: string, keyData: ArrayBuffer, algorithm: T, extractable: boolean, usages: string[]` | `Result<CryptoKey, Error>` | Import a key from the `keyData`in the `format` specified. Return a result set containing the `CryptoKey` or an `Error`.|
        |`Crypto.Subtle`| `exportKey` | `format: string, key: CryptoKey`| `Result<ArrayBuffer, Error>` | Export the `key` in the specified `format`. Return a result set containing a `ArrayBuffer` of the exported key or an `Error`.|

        Depending on the type of Key to export or import the format to use are the following: `raw`, `spki`, `pkcs8`, `pkcs1`, `sec1`.

        If the key is not `extractable` then export will fail.

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function subtleCryptoExportImportKey(): void
        {
            // Generate AES key to export
            let aesKeyResult = Crypto.Subtle.generateKey({length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
            let aesKey = aesKeyResult.data as Crypto.CryptoKey;

            // Export and Import
            let aesKeyExport = Crypto.Subtle.exportKey("raw", aesKey);
            let importedAesKey = Crypto.Subtle.importKey("raw", aesKeyExport.data, {length: 256} as Crypto.AesKeyGenParams, true, ["encrypt", "decrypt"]);
        }
        ```
    </Tab>
    <Tab value="Rust">
        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `import_key` | `format: string, keyData: [u8], algorithm: GenAlgorithm, extractable: bool, usages: [&str]` | `Result<CryptoKey, Error>` | Import a key from the `keyData`in the `format` specified. Return a result set containing the `CryptoKey` or an `Error`.|
        |`crypto::subtle`| `export_key` | `format: string, key: CryptoKey`| `Result<Vec<u8>, Error>` | Export the `key` in the specified `format`. Return a result set containing a `Vec<u8>` of the exported key or an `Error`.|

        Depending on the type of Key to export or import the format to use are the following: `raw`, `spki`, `pkcs8`, `pkcs1`, `sec1`.

        If the key is not `extractable` then export will fail.

        ```rust
        use klave::{self, crypto::subtle, crypto::subtle::CryptoKey};

        fn subtle_crypto_export_import_key(input: String) {
            // Generate AES key
            let aes_params = subtle::AesKeyGenParams { length: 256 };
            let key_usages: Vec<&str> = vec!["encrypt", "decrypt"];
            let gen_algorithm = subtle::KeyGenAlgorithm::Aes(aes_params);
            let crypto_key: CryptoKey = match subtle::generate_key(&gen_algorithm, true, &key_usages) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Export the Key
            let exported_key = match subtle::export_key("raw", &crypto_key) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };

            // Import the Key
            let imported_key = match subtle::import_key("raw", &exported_key, &gen_algorithm, true, &key_usages) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            }
        }
        ```
    </Tab>
</Tabs>

## Making data digest
<Tabs groupId="language" items={['AssemblyScript', 'Rust']}>
    <Tab value="AssemblyScript">
        The interface can be accessed through the `Crypto.SHA` keyword and is compatible with SHA2 and SHA3 digest.

        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`Crypto.Subtle`| `digest` | `algorithm: string, data: ArrayBuffer` | `Result<ArrayBuffer, Error>`  | Generate a digest of the `data` based on the `algorithm` specified. Return a ResultSet `Result<ArrayBuffer, Error>` containing either the digest in an `ArrayBuffer` or an `Error`.|

        ```js copy
        import { Crypto } from '@klave/sdk';

        /**
        * @query
        */
        export function CryptoSHA_Test(): void
        {
            let data = String.UTF8.encode("Hello World");
            let sha256 = Crypto.Subtle.digest("SHA2-256", data);
            let sha384 = Crypto.Subtle.digest("SHA2-384", data);
            let sha512 = Crypto.Subtle.digest("SHA2-512", data);
            let sha3_256 = Crypto.Subtle.digest("SHA3-256", data);
            let sha3_384 = Crypto.Subtle.digest("SHA3-384", data);
            let sha3_512 = Crypto.Subtle.digest("SHA3-512", data);
        }
        ```
    </Tab>
    <Tab value="Rust">

        | Class  | Operation  | Parameters: type | Returns | Behavior |
        |--------|------------|------------------|---------|----------|
        |`crypto::subtle`| `digest` | `algorithm: string, data: [u8]` | `Result<Vec<u8>, Error>`  | Generate a digest of the `data` based on the `algorithm` specified. Return a ResultSet `Result<Vec<u8>, Error>` containing either the digest in an `Vec<u8>` or an `Error`.|

        ```rust
        use klave::{self, crypto::subtle}

        fn digest(input: String) {
            // Digest : SHA2-256, SHA2-384, SHA2-512, SHA3-256, SHA3-384, SHA3-512
            let digest = match sha::digest("SHA2-256", &String::from("Hello World").into_bytes()) {
                Ok(result) => result,
                Err(err) => {
                    klave::notifier::send_string(&err.to_string());
                    return;
                }
            };
        }
        ```
    </Tab>
</Tabs>
