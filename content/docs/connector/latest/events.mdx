---
title: Events
---

import Image from 'next/image';

This section describes how to call queries and transactions that you have defined in your Klave application.
For more information about State Management on Klave and the definition of a Query and a Transaction, please refer to the [State Management](/concepts/state-management) section.


## Query api

After having established the connection to Klave, you create a Query object using the api `newQuery` of the `SCP` class.
The `newQuery` method takes as arguments the application name, the command name, the request id and the arguments of the command name.

| Class  | Operation  | Parameters | Returns | Behavior |
|--------|------------|------------|---------|----------|
|`SCP`| `newQuery`  | `app:string, command: string, requestId?: string, args?: Record<string, unknown> \| string` | `Query<>` | Execute and `HttpRequest` and return an `HttpResponse`|

 Prior to call queries or perform transactions, you need first Both queries and transactions are called using the `sendQuery` method of the `Notifier` class.

For example, we will use the query and transaction provided in the trustless app when creating a new application.
The transaction allows storing a key/value in the ledger as an entry of the table "my_storage_table", while the query allows you to fetch the value associated to a key.
Below are examples of how to define and use these in AssemblyScript.

<Tabs items={['AssemblyScript']}>
<Tab value="AssemblyScript">
```ts
import { Notifier, Ledger, JSON } from '@klave/sdk';
import { FetchInput, FetchOutput, StoreInput, StoreOutput, ErrorMessage } from './types';

const myTableName = "my_storage_table";

/**
 * @query
 * @param {FetchInput} input - A parsed input argument
 */
export function fetchValue(input: FetchInput): void {

    let value = Ledger.getTable(myTableName).get(input.key);
    if (value.length === 0) {
        Notifier.sendJson<ErrorMessage>({
            success: false,
            message: `key '${input.key}' not found in table`
        });
    } else {
        Notifier.sendJson<FetchOutput>({
            success: true,
            value
        });
    }
}

/**
 * @transaction
 * @param {StoreInput} input - A parsed input argument
 */
export function storeValue(input: StoreInput): void {

    if (input.key && input.value) {
        Ledger.getTable(myTableName).set(input.key, input.value);
        Notifier.sendJson<StoreOutput>({
            success: true
        });
        return;
    }

    Notifier.sendJson<ErrorMessage>({
        success: false,
        message: `Missing value arguments`
    });
}
```
</Tab>
</Tabs>

<Tabs items={['TypeScript']}>
<Tab value="TypeScript">
```js
import { Key, SCP } from '@secretarium/connector';

async function main() {
    
    // We create the new connector context
    const context = new SCP();
    // We create a new connection key or provide an existing one
    const myKey = await Key.createKey()
    // We start the connection to Klave
    const connection = await context.connect('wss://on.klave.network', myKey)
}

main()
```
<Callout type="info" emoji="ℹ️">
    The default `createKey` method uses the SubtleCrypto library to generate a cryptographic key with ECDSA algorithm and P-256 curve,
    extractable and whose usages allow to sign and verify.
</Callout>
</Tab>
<Tab value="Python">
```py
import asyncio
from secretarium_connector import SCP, Key

async def main():

    #We create the new connector context
    context = SCP()

    #We create a new connection key or provide an existing one
    myKey = await Key.createKey()

    #We start the connection to Klave
    connection = await context.connect('wss://on.klave.network', myKey)

asyncio.run(main())
```
<Callout type="info" emoji="ℹ️">
    The default `createKey` method uses the python library `cryptography.hazmat` particularly the elliptic curve module
    to generate a private key with ECDSA algorithm and "secp256r1" curve.
</Callout>
</Tab>
</Tabs>




## Connecting to Klave importing an existing key

Using a pre-defined key or set of keys can be particularly useful as Klave provides through its context the connection key.
This allows to whitelist in your Klave application a specific key for a specific usage.
To this end, we provide methods to export/import keys in clear text, or export/import keys in encrypted format.

<Tabs items={['TypeScript', 'Python']}>
<Tab value="TypeScript">
```js
import { SCP } from '@secretarium/connector';

async function main() {
    
    // We create the new connector context
    const context = new SCP();
    
    // We create a key and export/import it to/from clear text
    const myKey1 = await Key.createKey();
    const myExportedKey = await myKey1.exportKey();
    const myImportedKey1 = await Key.importKey(myExportedKey);

    // We create a key and export/import it to/from encrypted text
    const myKey2 = await Key.createKey();
    const myEncryptedKey = myKey2.seal('password');
    const myExportedEncryptedKey = await myEncryptedKey.exportEncryptedKey();
    const myImportedKey2 = await Key.importKey(myExportedEncryptedKey);

    // We start the connection to Klave
    const connection = await context.connect('wss://on.klave.network', myImportedKey2)
}

main()
```
<Callout type="info" emoji="ℹ️">
    The `importKey` method assumes the public and private key to be provided in JWK format.
</Callout>
</Tab>
<Tab value="Python">
```py
import asyncio
from secretarium_connector import SCP, Key

async def main():

    #We create the new connector context
    context = SCP()

    #We create a new connection key or provide an existing one
    myKey = await Key.createKey()

    #We start the connection to Klave
    connection = await context.connect('wss://on.klave.network', myKey)

asyncio.run(main())
```
</Tab>
</Tabs>

